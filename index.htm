<!DOCTYPE html>
<html>
    <head>
        <title>Canvas playground</title>
        <style type="text/css">
            #canvas {
                width: 1080px;
                height: 1350px;
                border: 1px solid black;
                margin: auto;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" width="1080" height="1350"></canvas>

        <script type="text/template" id="lyrics">
            [00:03.000]Line 1 lyrics Line 1 lyrics
            [00:07.200]Line 2 lyrics
            [00:11.100]Line 3 lyrics
            [00:14.000]Line 4 lyrics Line 4 lyrics Line 4 lyrics
            [00:18.250]Line 5 lyrics
            [00:19.020]Line 6 lyrics
            [00:21.130](end)
        </script>

        <script type="text/javascript">
            class Lyric {
                constructor(line) {
                    let regex = /^\[(?<minutes>\d+)\:(?<seconds>\d+)\.(?<milliseconds>\d+)\](?<lyric>.*)$/,
                        data = line.trim().match(regex).groups;
                    this.minutes = parseInt(data.minutes);
                    this.seconds = parseInt(data.seconds);
                    this.milliseconds = parseInt(data.milliseconds);
                    this.text = data.lyric;
                }

                startTimeInMilliseconds () {
                    return ((this.minutes * 60) + this.seconds) * 1000 + this.milliseconds;
                }
            }

            class Song {
                constructor(lyricsText) {
                    let prevTime = 0;
                    this.parseLyrics(lyricsText);
                    this.addStartLyric();
                    this.numLyrics = this.lyrics.length;
                }

                parseLyrics(lyricsText) {
                    let lyrics = lyricsText.split("\n")
                    .filter((line) => {
                        return line.trim().length > 0;
                    });
                    lyrics = lyrics.map((line) => {
                        // first create an array of Lyrics
                        let lyric = new Lyric(line);
                        return {
                            lyric: lyric,
                            duration: 0
                        };
                    });
                    // then caluclate each one's duration, based on the time of the previous one
                    for (let i = lyrics.length - 1; i >= 0; i--) {
                        let duration = 1; // default to 1 rather than 0 as it helps with 'elapsed' calculation later
                        if (i < lyrics.length - 1) {
                            duration = lyrics[i + 1].lyric.startTimeInMilliseconds() -
                                lyrics[i].lyric.startTimeInMilliseconds();
                        }
                        lyrics[i].duration = duration;
                    }
                    this.lyrics = lyrics;
                }

                get duration() {
                    if (!this.length) {
                        const lastLyric = this.lyrics[this.lyrics.length-1].lyric;
                        this.length = lastLyric.startTimeInMilliseconds()
                    }
                    return this.length;
                }

                activeLyric(elapsed) {
                    let index = 1, stop = false, activeLyric = null;
                    while (!stop && index < this.numLyrics) {
                        if (this.lyrics[index].lyric.startTimeInMilliseconds() > elapsed) {
                            stop = true;
                        }
                        else {
                            index++;
                        }
                    }
                    if (stop) {
                        activeLyric = this.lyrics[index-1];
                    }
                    return activeLyric;
                }

                addStartLyric() {
                    let startLyric = {
                        lyric: new Lyric('[00:00.000](start)'),
                        duration: this.lyrics[0].lyric.startTimeInMilliseconds()
                    };
                    this.lyrics = [startLyric, ...this.lyrics];
                }
            }

            class LyricVideo {
                // @param options.fontSize - font size
                // @param options.lineHeight - line height
                // @param options.startX
                // @param options.startYs
                // @param options.activeColor
                // @param options.inactiveColor
                constructor(song, canvas, options = {}) {
                    this.song = song;
                    this.canvas = canvas;
                    this.ctx = this.canvas.getContext('2d');
                    this.width = this.canvas.width;
                    this.height = this.canvas.height;
                    this.fontSize = options.fontSize || 70;
                    this.lineHeight = options.lineHeight || (this.fontSize * 1.5);
                    this.startY = options.startY || ((this.fontSize / 2) + (this.lineHeight * 5));
                    this.startX = options.startX || this.lineHeight;
                    this.activeColor = options.activeColor || 'red';
                    this.inactiveColor = options.inactiveColor || 'grey';
                    this.endX = this.width - this.startX; // width of the div => width - lineHeight in pixels on each side
                    this.timeoutFunction = null;
                    this._animationStartTime = null;

                    this.ctx.fillStyle = this.activeColor;
                    this.ctx.font= "bold " + this.fontSize + "px Verdana"; // "px Handjet";
                    this.ctx.textAlign = "center";
                }

                start() {
                    requestAnimationFrame((timestamp) => {this.draw(0)});
                    requestAnimationFrame((timestamp) => {this.drawStatusBar(timestamp)});
                }

                end() {
                    delete this.timeoutFunction;
                    this._animationStartTime = null;
                }

                setTimeout(...args) {
                    this.timeoutFunction = setTimeout(...args);
                }

                draw(i) {
                    let textStart = this.width / 2; // helps with centering the text
                    let songLyric = this.song.lyrics[i];
                    this.ctx.clearRect(0, 0, this.width, this.height);
                    this.ctx.fillStyle = this.activeColor;
                    let splitLines = this.wrapText(songLyric.lyric.text),
                        numLines = splitLines.length,
                        thisY = this.startY,
                        j = 0;
                    splitLines.forEach(line => {
                        thisY = thisY + (this.lineHeight * j);
                        this.ctx.fillText(line, textStart, thisY);
                        j++;
                    });
                    if (i < this.song.numLyrics-1) {
                        // draw next line below
                        thisY += this.lineHeight, j = 0; // move to next line and reset counter
                        this.ctx.fillStyle = this.inactiveColor;
                        // can use thisY and j from above
                        let splitLines = this.wrapText(this.song.lyrics[i+1].lyric.text);
                        splitLines.forEach(line => {
                            thisY = thisY + (this.lineHeight * j);
                            this.ctx.fillText(line, textStart, thisY);
                            j++;
                        });
                    }
                    if (i > 0) {
                        // draw previous line above
                        this.ctx.fillStyle = this.inactiveColor;
                        let splitLines = this.wrapText(this.song.lyrics[i-1].lyric.text);
                        thisY = this.startY - this.lineHeight; // move to previous line from middle
                        let numSplitLines = splitLines.length;
                        for (let k = numSplitLines - 1, j=0;  k >= 0; k--, j++ ) {
                            thisY = thisY - (this.lineHeight * j);
                            this.ctx.fillText(splitLines[k], textStart, thisY);
                        }
                    }
                    i++;
                    if (i < this.song.numLyrics) {
                        this.setTimeout(() => { this.draw(i)}, songLyric.duration);
                    }
                    else {
                        this.end();
                    }
                }

                drawStatusBar(timestamp) {
                    let keepDrawing = true;
                    if (!isNaN(timestamp)) {
                        this._animationStartTime = this._animationStartTime || timestamp;
                        const duration = this.song.duration,
                            elapsed = timestamp - this._animationStartTime,
                            fraction = elapsed / duration;
                        this.ctx.save();
                        this.ctx.fillStyle = this.inactiveColor;
                        this.ctx.fillRect(0, this.height - 20, Math.round(fraction * this.width), 20);
                        this.ctx.restore();
                        keepDrawing = fraction < 1;
                        if (keepDrawing) {
                            this.drawLyricStatusBar(timestamp, elapsed);
                        }
                    }
                    if (keepDrawing) {
                        requestAnimationFrame((ts) => {this.drawStatusBar(ts)});
                    }
                }

                drawLyricStatusBar(timestamp, elapsed) {
                    let activeLyric = this.song.activeLyric(elapsed);
                    if (null === activeLyric) {
                        return;
                    }
                    this._previousLyricFraction = this._previousLyricFraction || 0;

                    const lyricElapsed = Math.round(elapsed - activeLyric.lyric.startTimeInMilliseconds()),
                        lyricDuration =  activeLyric.duration;
                    let fraction = lyricElapsed / lyricDuration;
                    if (fraction < this._previousLyricFraction || fraction >= 1) {
                        // we're on to a new lyric
                        delete this._previousLyricFraction;
                        fraction = 1;
                    }
                    else {
                        this._previousLyricFraction = fraction;
                    }
                    this.ctx.save();
                    this.ctx.fillStyle = this.activeColor;
                    this.ctx.fillRect(0, this.height - 40, Math.round(fraction * this.width), 20);
                    this.ctx.restore();
                }

                // @description: wrapText wraps HTML canvas text onto a canvas of fixed width
                // @param text - the text we want to wrap.
                // @returns an array of lineText strings for all lines
                wrapText(text) {
                    // First, start by splitting all of our text into words, but splitting it into an array split by spaces
                    let words = text.split(' ');
                    let line = ''; // This will store the text of the current line
                    let testLine = ''; // This will store the text when we add a word, to test if it's too long
                    let lineArray = []; // This is an array of lines, which the function will return
                    let y = Math.round(this.lineHeight / 6); // 1/2 the fontSize of a gap from the top

                    // Lets iterate over each word
                    for (var n = 0; n < words.length; n++) {
                        // Create a test line, and measure it..
                        testLine += `${words[n]} `;
                        let metrics = this.ctx.measureText(testLine);
                        let testWidth = metrics.width;
                        // If the width of this test line is more than the max width
                        if (testWidth > this.endX && n > 0) {
                            // Then the line is finished, push the current line into "lineArray"
                            lineArray.push(line);
                            // Increase the line height, so a new line is started
                            y += this.lineHeight;
                            // Update line and test line to use this word as the first word on the next line
                            line = `${words[n]} `;
                            testLine = `${words[n]} `;
                        }
                        else {
                            // If the test line is still less than the max width, then add the word to the current line
                            line += `${words[n]} `;
                        }
                        // If we never reach the full max width, then there is only one line.. so push it into the lineArray so we return something
                        if (n === words.length - 1) {
                            lineArray.push(line);
                        }
                    }
                    // Return the line array
                    return lineArray;
                }
            }

            const canvas = document.getElementById("canvas");

            let myFont = new FontFace(
                "Handjet",
                "url(https://fonts.gstatic.com/s/nerkoone/v16/m8JQjfZSc7OXlB3ZMOjDd5RARGmK3Q.woff2)"
            );

            let song, video;
            myFont.load().then((font) => {
                document.fonts.add(font);
                song = new Song(document.getElementById('lyrics').innerHTML.trim());
                video = new LyricVideo(song, canvas);
                video.start();
            });

        </script>
    </body>
</html>